---
title:  "1분복습 : DFS, BFS 문제를 맞이하는 나의 자세"
excerpt: "최다 빈출 유형 중 하나인 DFS, BFS 문제를 마주했을 때, 촉박한 시간 내에서 실수없이 문제를 풀기 위해 가져야 할 마음을 정리해봅니다. 온전히 제 의견입니다."

categories:
  - PS
tags:
  - PS
  - Algorithm
last_modified_at: 2020-03-16TO11:30:00+09:00
---
# 나의 고민
> DFS, BFS 알고리즘은 문장 순서, 변수 사용 등 고려해야할 점이 많다. 최근 실제 코딩테스트를 참가하고, 촉박한 시간에서 잦은 실수로 오랜 시간을 DFS, BFS에 소비했다. 다음에도 이러지 않기 위해, DFS, BFS 문제 유형만큼은 잘 풀 수 있도록 내 나름대로의 고민의 결과를 정리한다.

## 생각을 코드로 구현하는 과정에서
1. 모든 loop에서 동일하게 사용하는 int[] map 이라던지, int weight 등의 변수에 대해서. 변수를 static으로 만들어서 함수가 보다 단순해 보일 수 있도록 한다. 실제 코드 개발이 아닌 지금 앞에 놓여진 문제를 풀어내는 것이 제일 중요하므로.

2. 일단 모든 경우를 다 탐색하는, 전체 탐색의 DFS BFS 코드부터 짠다. 가지치기(최적화)는 일단 돌려보고 시간초과하면 한다. 
> 처음부터 가지치기를 고려하면 머리가 복잡해져서 결국 잘못된 코드를 작성하는 경우가 많았다.

3. DFS : depth 변수, BFS : distance 변수 추가하기 전에, 기본 틀이 되는 코드부터 완성하자.

4. DFS의 경우 visited는 acylic 그래프이면 안만들어도 된다. 

5. 변수를 줄이고, 코드를 짧게 만드는 것에 너무 신경쓰지 말자. 깔끔한 코드는 중요하지만, 문제 조건에 벗어나지 않는 다면 내가 이해하기 쉽게 코드를 짜는 것도 문제를 신속히 풀어내는 것에 중요한 것 같다.

6. DFS(depth = k, cost) 호출시 담겨있는 cost에 update를 해줘야 k번째 cost 넘겨줄 수 있는지, 아니면 k번째 cost가 바로 넘어오는건지 구분 잘하기.
> for문을 어디에 위치 시킬지. if문으로 return을 먹일지. 아니면 if-else문으로 분기를 시킬지. 위의 생각이 주요한 판단의 근거가 된다.

## 이 문제는 BFS? DFS?
- BFS: 보통 최단거리 구하는 1가지 유형에만 사용
- DFS: 그래프 문제에 따라 더 다양하게 사용
BFS > 최단 경로를 보장한다.<br>
DFS > 모든 경로 방문하고자 하는 경우에 적합하다.


### 참고 출처
[https://sungjk.github.io/2016/05/12/BFS.html](https://sungjk.github.io/2016/05/12/BFS.html)
